%{

def join(xs, j):
	return j.join(xs)
def ifx(c, y, n):
	if c:
		return y
	else:
		return n

n_list = [2, 3, 4, 5]

}%
#pragma once

#include "./assert.h"
#include "./fatal.h"
#include "./std_dependency.h"

namespace rhetoric {
    template <int C, typename T> class EitherCaseWrapper;
    
    template <int C, typename T>
    EitherCaseWrapper<C, T> EitherCase(const T & value);
    
% for n in n_list:
%{
    class_name = "Either{}".format(n)

    t_vars = ["T{}".format(i) for i in range(n)]
    typename_t_vars = ["typename {}".format(t) for t in t_vars]
    
    class_name_ts = "{}<{}>".format(class_name, join(t_vars, ", "))
    
    u_vars = ["U{}".format(i) for i in range(n)]
    typename_u_vars = ["typename {}".format(u) for u in u_vars]
}%
    template <${join(typename_t_vars, ", ")}>
    class ${class_name} {
    public:
        enum class Tag : int8_t {
%   for i in range(n):
            Case${i}${ifx(i < n-1, ",", "")}
%   end
        };
        
        ${class_name}() = delete;
%   for i in range(n):
        /* implicit */ ${class_name}(const EitherCaseWrapper<${i}, ${t_vars[i]}> & value);
%   end
        ${class_name}(const ${class_name_ts} & other);
        template <${join(typename_u_vars, ", ")}>
        ${class_name}(const ${class_name}<${join(u_vars, ", ")}> & other,
                typename std::enable_if<
%   for i in range(n):
                    std::is_convertible<U${i}, T${i}>::value${ifx(i < n-1, " &&", "")}
%   end
                >::type * = nullptr);
        ${class_name_ts} & operator= (const ${class_name_ts} & other);
        ~${class_name}();
        
        Tag tag() const;
%   for i in range(n):
        const T${i} & AsCase${i}() const;
%   end
    private:
        union Storage {
%   for i in range(n):
            T${i} value${i};
%   end

            Storage();
            ~Storage();
        };

%   for i in range(n):
        void InitValue${i}(const T${i} & value);
%   end    
        void Deinit();
        
        Storage storage_;
        Tag tag_;
    };

% end
    template <int C, typename T>
    struct EitherCaseWrapper {
        T value;
        EitherCaseWrapper(const T & value);
    };
    
}

#include "./either_inline.h"
