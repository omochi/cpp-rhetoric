%{
def join(xs, j=", "):
  return j.join(xs)
def ifx(c, y, n):
  if c:
    return y
  else:
    return n
def either(n):
  return "Either{}".format(n)
def either_ts(n, t):
  return "{}<{}>".format(either(n), join(t_vars(t, n)))
def t_vars(t, n):
  return ["{}{}".format(t, i) for i in range(n)]
def typename_t_vars(t, n):
  return ["typename {}{}".format(t, i) for i in range(n)]

n_list = [2, 3, 4, 5]
}%
#pragma once

#include "./assert.h"
#include "./fatal.h"
#include "./std_dependency.h"

namespace rhetoric {
    template <int C, typename T> class EitherCaseWrapper;
    
    template <int C, typename T>
    EitherCaseWrapper<C, T> EitherCase(const T & value);
    
% for n in n_list:
    template <${join(typename_t_vars("T", n))}>
    class ${either(n)} {
    public:
        enum class Tag : int8_t {
%   for i in range(n):
            Case${i}${ifx(i < n-1, ",", "")}
%   end
        };
        
        ${either(n)}() = delete;
%   for i in range(n):
        /* implicit */ ${either(n)}(const EitherCaseWrapper<${i}, T${i}> & value);
%   end
        ${either(n)}(const ${either_ts(n, "T")} & other);
        template <${join(typename_t_vars("U", n))}>
        ${either(n)}(
        	const ${either_ts(n, "U")} & other,
            typename std::enable_if<
%   for i in range(n):
                std::is_convertible<U${i}, T${i}>::value${ifx(i < n-1, " &&", "")}
%   end
            >::type * = nullptr);
        ${either_ts(n, "T")} & operator= (const ${either_ts(n, "T")} & other);
        ~${either(n)}();
        
        Tag tag() const;
%   for i in range(n):
        const T${i} & AsCase${i}() const;
%   end
    private:
        union Storage {
%   for i in range(n):
            T${i} value${i};
%   end

            Storage();
            ~Storage();
        };

%   for i in range(n):
        void InitValue${i}(const T${i} & value);
%   end    
        void Deinit();
        
        Storage storage_;
        Tag tag_;
    };

% end
    template <int C, typename T>
    struct EitherCaseWrapper {
        T value;
        EitherCaseWrapper(const T & value);
    };
    
}

#include "./either_inline.h"
